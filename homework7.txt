# 1

# Вводим основания той системы координат в которую нужно преобразовать
txt = str(input("введите основание для системы счисления 'b' или 'o' или 'x'"))
# Вводим число которое нужно приобразовать
decimal_number = int(input("Введите целое число для преобразования"))
# Производим преобразования указаново числа в указанную систему координат
hex_number = format(decimal_number, txt)
# Выводим результат
print(hex_number)  

# 2

# Вводим целочисленое число
number = int(input("Введите целое чмсло: "))
# Вводим номер бита который нужно определить 
bit = int(input("Bit: "))
# Переводим введеное число в двоичную систему (чисто для себя что бы проверить правильность определения)
print(format(number, "b"))
# number >> bit этой операцией сдвигаем двоичный код в лего, (прм. 11100 > 111), & 1 тут определяем какой у нас бит рабочий или выключеный 
print((number >> bit) & 1)

# 3

# Вводим целочисленое число
number = int(input("Введите целое чмсло: "))
# Производим преобразования указаново числа в двоичную систему координат
binary = format(number, 'b')
# Переводим введеное число в двоичную систему (чисто для себя что бы проверить правильность определения)
print(binary)
# Создаем переменную для подсчета всех битов числа
s = 0
# Вычисляем сумму всех битов введенного числа
for k in binary:
    if k == '1':
        s = s + 1
# Выводим результат в лесятеричной и двоичной системе
print(f"Сумма всех битов = {s},", "в двоичной системе = " + format(s, 'b'))

# 4

# Вводим целочисленое число
number = int(input("Введите целое чмсло: "))
# Производим преобразования указаново числа в восмиричную систему координат
octal = format(number, 'o')
# Проверяем введеное число в восмиричную систему (чисто для себя что бы проверить правильность определения)
print(octal)
# Меняем порадок следования цифр
upend = octal[::-1] 
# Проверяем изменения порадка следования цифр (чисто для себя что бы проверить правильность определения)   
print(upend)
# Производим преобразования указаново числа из восмиричную системы координат в десятиричную систему
print(int(upend,8))

# 5 

# Импорт класса из модуля 
from fractions import Fraction
A = Fraction(input("Введите первую рациональную дробь"))
B = Fraction(input("Введите вторую рациональную дробь"))
sum = A + B
residual = A - B
multiplication = A * B
quotient = A / B
# Проверяем вычисления с двумя дробями (чисто для себя что бы проверить правильность результата) 
print(f'{A}+{B} = {sum}\n{A}-{B} = {residual}\n{A}*{B} = {multiplication}\n({A})/({B}) = {quotient}')
# Создаем списак из полученых результатов
list = [sum, residual, multiplication, quotient]
# Определяем максимальное и минемальное значения из полученного списка
max, min = max(list), min(list)
# Выводим полученный результат
print(f'Наибольшее значение = {max} \nНаименьшее значение = {min}')

# 6

A = complex(int(input("Введите действительное число")), int(input("Введите мнимое число")))
print("A =", A)
B = complex(int(input("Введите действительное число")), int(input("Введите мнимое число")))
print("B =", B)
sum = A + B
residual = A - B
multiplication = A * B
quotient = A / B
# Проверяем вычисления комплексных чисел (чисто для себя что бы проверить правильность результата) 
print(f'{A}+{B} = {sum}\n{A}-{B} = {residual}\n{A}*{B} = {multiplication}\n({A})/({B}) = {quotient}')
# Определяем модуль полученого комплексного числа после вычисления
sum_abs, residual_abs, multiplication_abs, quotient_abs = abs(sum), abs(residual), abs(multiplication), abs(quotient)
# Создаем списак из полученых результатов
list = [sum_abs, residual_abs, multiplication_abs, quotient_abs]
# Определяем максимальное и минемальное значения из полученного списка
max, min = max(list), min(list)
# Выводим полученный результат
print(f'Наибольшее значение = {max} \nНаименьшее значение = {min}')

# 7

# Импорт класса из модуля 
from datetime import date
# Объект для реализации первой даты
firstdate = date(int(input("Введите год")), int(input("Введите месяц")), int(input("Введите день")))
# Объект для реализации второй даты
second_date = date(int(input("Введите год")), int(input("Введите месяц")), int(input("Введите день")))
# Проверка результата
print("Первая дата:", firstdate)
print("Вторая дата:", second_date)
# Разность дат
delta = firstdate - second_date
# Проверка результата
print("До первой даты:", delta)

# 8

# Импорт класса из модуля
from datetime import datetime
import pytz
# Объект для реализации даты и времени
md = datetime(int(input("Введите год")), int(input("Введите месяц")), int(input("Введите день")), int(input("Введите час")), int(input("Введите минуты")), int(input("Введите секунды")))
# Проверка результата
print("Дата и время:", md)
# Объект для текущей даты и времени
td = datetime.today()
# Проверка результата
print("Сегодня и сейчас:", td)
# Разность дат
delta = md - td
# Проверка результата
print("Интервал времени:", delta)
print("Дни:", delta.days)
print("Секунды:", delta.seconds)
print("Интервал в секундах:", delta.total_seconds())

# 9

# Открываем текстовый файл для чтения
mf = open(input("Введите путь к файлу: "))
print("Запись нового вайла будет проискодить по адресу D:\\my\\Python\\books1.txt")
# Создаем новый файл для записи 
nf = open("D:\\my\\Python\\books1.txt", "w+t")
# Переменная для нумерации строк
k = 1
# Построчное считование файла 
print("Построчное считование файла")
for L in mf.readlines():
    # Отображение самой строки
    print(L, end = "")    
    # Копирование строки с их нумерацией в новый файл
    nf.write("["+str(k)+"]" + L)
    # Новое значение для номера строки
    k = k +1
print("Копирование прошло успешно")   
# Закрываем файл
nf.close()
mf.close()
print("Файлы закрыты...")

# 10

try:        
    # Вводим текст 
    txt = input("Введите текст: ")
    # Переводим все симвалы в верхний регистр
    up_txt = txt.upper()
    # Вводим имя файла
    name_f = input("Введите имя файла: ")
    # Файл открывается для записи
    mf = open(f"D:\\my\\Python\\{name_f}.txt", "x")
    # Текст записовается в файл 
    mf.write(up_txt)
    # Закревается файл
    mf.close()
    # Сообщение о завершении копирования
    print("Текст записан в файл")
# Если второй файл уже существует
except FileExistsError:
    print("Ошибка: такой файл уже существует")
# Все прочии ошибки 
except:
    print("Ошибка доступа к файлу")
print("Программа завершила выполнения")     